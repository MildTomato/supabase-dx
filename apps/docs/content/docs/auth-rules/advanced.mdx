---
title: Advanced patterns
description: Complex authorization scenarios
---

These patterns cover more sophisticated access control scenarios you might
encounter in production applications.

## Different access by role

Users with different roles see different data within the same org:

- **Admins** see all documents in their orgs
- **Members** see only documents they created
- **Viewers** see only public documents

Build this with `or_` to combine conditions:

```sql title="claims.sql"
SELECT auth_rules.claim('org_roles', $$
  SELECT user_id, org_id, role FROM org_members
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('documents',
  auth_rules.select('id', 'org_id', 'title', 'is_public', 'created_by'),
  auth_rules.or_(
    -- Admins see everything in their orgs
    auth_rules.in_claim('org_id', 'org_ids',
      auth_rules.check('org_roles', 'role', ARRAY['admin'])),
    -- Members see their own documents
    auth_rules.and_(
      auth_rules.in_claim('org_id', 'org_ids',
        auth_rules.check('org_roles', 'role', ARRAY['member'])),
      auth_rules.eq('created_by', auth_rules.user_id())
    ),
    -- Viewers see only public documents
    auth_rules.and_(
      auth_rules.in_claim('org_id', 'org_ids',
        auth_rules.check('org_roles', 'role', ARRAY['viewer'])),
      auth_rules.eq('is_public', true)
    )
  )
);
```

## Hierarchical teams

Users in a parent team can access all child team resources:

```
Engineering (user is member)
├── Frontend
│   └── React Squad
└── Backend
```

Use a recursive CTE in your claim:

```sql title="claims.sql"
SELECT auth_rules.claim('accessible_team_ids', $$
  WITH RECURSIVE team_tree AS (
    -- Direct membership
    SELECT user_id, team_id FROM team_members
    UNION
    -- Inherit access to child teams
    SELECT tt.user_id, t.id AS team_id
    FROM team_tree tt
    JOIN teams t ON t.parent_team_id = tt.team_id
  )
  SELECT DISTINCT user_id, team_id FROM team_tree
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('team_resources',
  auth_rules.select('id', 'team_id', 'name'),
  auth_rules.eq('team_id', auth_rules.one_of('accessible_team_ids'))
);
```

## Time-limited access

Course content is only available during enrollment:

```sql title="claims.sql"
SELECT auth_rules.claim('active_course_ids', $$
  SELECT user_id, course_id
  FROM enrollments
  WHERE starts_at <= now() AND ends_at >= now()
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('course_content',
  auth_rules.select('id', 'course_id', 'title', 'video_url'),
  auth_rules.eq('course_id', auth_rules.one_of('active_course_ids'))
);
```

When the enrollment expires, access stops automatically — no background jobs needed.

## Cross-tenant sharing

When Tenant A wants to share specific resources with Tenant B:

```sql title="claims.sql"
-- User's own tenants
SELECT auth_rules.claim('tenant_ids', $$
  SELECT user_id, tenant_id FROM tenant_users
$$);

-- Resources shared with user's tenants
SELECT auth_rules.claim('shared_resource_ids', $$
  SELECT tu.user_id, rs.resource_id
  FROM tenant_users tu
  JOIN resource_shares rs ON rs.shared_with_tenant_id = tu.tenant_id
$$);
```

Combine owned and shared access:

```sql title="rules.sql"
SELECT auth_rules.rule('resources',
  auth_rules.select('id', 'tenant_id', 'name'),
  auth_rules.or_(
    auth_rules.eq('tenant_id', auth_rules.one_of('tenant_ids')),
    auth_rules.eq('id', auth_rules.one_of('shared_resource_ids'))
  )
);
```

## Slack-style channels

This pattern handles workspaces with public and private channels:

```sql title="claims.sql"
-- Workspaces user belongs to
SELECT auth_rules.claim('workspace_ids', $$
  SELECT user_id, workspace_id FROM workspace_members
$$);

-- Private channels user is explicitly added to
SELECT auth_rules.claim('private_channel_ids', $$
  SELECT cm.user_id, cm.channel_id
  FROM channel_members cm
  JOIN channels c ON c.id = cm.channel_id
  WHERE c.is_private = TRUE
$$);
```

Public channels visible to all workspace members, private channels only to members:

```sql title="rules.sql"
SELECT auth_rules.rule('channels',
  auth_rules.select('id', 'workspace_id', 'name', 'is_private'),
  auth_rules.and_(
    auth_rules.eq('workspace_id', auth_rules.one_of('workspace_ids')),
    auth_rules.or_(
      auth_rules.eq('is_private', false),
      auth_rules.eq('id', auth_rules.one_of('private_channel_ids'))
    )
  )
);
```

## Dropbox-style folder sharing

When you share a folder, users get access to all files and subfolders inside
it:

```sql title="claims.sql"
-- Folders user can access (owned + shared, including subfolders)
SELECT auth_rules.claim('accessible_folder_ids', $$
  -- Folders user owns
  SELECT owner_id AS user_id, id FROM folders
  UNION
  -- Folders shared with user, plus all subfolders
  SELECT shares.shared_with_user_id AS user_id, descendant.id
  FROM shares
  JOIN LATERAL (
    WITH RECURSIVE folder_tree AS (
      SELECT id FROM folders WHERE id = shares.resource_id
      UNION ALL
      SELECT f.id FROM folders f
      JOIN folder_tree ft ON f.parent_id = ft.id
    )
    SELECT id FROM folder_tree
  ) descendant ON true
  WHERE shares.resource_type = 'folder'
$$);

-- Files user can access
SELECT auth_rules.claim('accessible_file_ids', $$
  -- Files user owns
  SELECT owner_id AS user_id, id FROM files
  UNION
  -- Files shared directly
  SELECT shared_with_user_id AS user_id, resource_id AS id
  FROM shares WHERE resource_type = 'file'
  UNION
  -- Files in accessible folders
  SELECT af.user_id, f.id
  FROM auth_rules_claims.accessible_folder_ids af
  JOIN files f ON f.folder_id = af.id
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('folders',
  auth_rules.select('id', 'parent_id', 'owner_id', 'name'),
  auth_rules.eq('id', auth_rules.one_of('accessible_folder_ids'))
);

SELECT auth_rules.rule('files',
  auth_rules.select('id', 'folder_id', 'owner_id', 'name', 'content'),
  auth_rules.eq('id', auth_rules.one_of('accessible_file_ids'))
);
```

## Pattern summary

Here's a quick reference for choosing the right approach:

| Scenario | Approach |
|----------|----------|
| Direct membership | Simple claim with `one_of()` |
| Role-based | Claim with role column + `check()` |
| Hierarchical | Recursive CTE in claim |
| Time-based | `WHERE` with `now()` in claim |
| Multiple paths | `UNION` in claim or `or_()` in rule |
| Conditional logic | `and_()` and `or_()` combinations |

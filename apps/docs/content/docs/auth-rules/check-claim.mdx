---
title: Role-based access
description: Control access based on user roles
---

Sometimes membership isn't enough — you need to know the user's
*role* within an organization. Auth Rules handles this with
`check()`.

## The problem

Say you have org members with different roles:

```sql title="schema.sql"
CREATE TABLE org_members (
  user_id UUID,
  org_id UUID,
  role TEXT  -- 'viewer', 'member', 'admin', 'owner'
);
```

All members can view documents, but only admins and owners can see
billing. You could create separate claims for each role, but that
doesn't scale well.

## The solution

Create one claim that includes the role:

```sql title="claims.sql"
SELECT auth_rules.claim('org_roles', $$
  SELECT user_id, org_id, role FROM org_members
$$);
```

Then use `check()` to filter by role:

```sql title="rules.sql"
SELECT auth_rules.rule('billing',
  auth_rules.select('id', 'org_id', 'amount', 'due_date'),
  auth_rules.in_claim('org_id', 'org_roles',
    auth_rules.check('org_roles', 'role', ARRAY['admin', 'owner']))
);
```

Users only see billing records for orgs where they're an admin or owner.

## How check() works

The `check()` function filters a claim by checking another column
within it. It's used with `in_claim()` to validate that a user's
claim row has the right property value.

```sql
auth_rules.check('claim_name', 'property_column', ARRAY['allowed', 'values'])
```

| Parameter | Description |
|-----------|-------------|
| `claim_name` | The claim to filter (must include the property column) |
| `property_column` | Column name in the claim to check (for example, `role`, `status`, `plan`) |
| `allowed_values` | Array of acceptable values for that column |

For example, if your `org_roles` claim has columns
`(user_id, org_id, role)`, you use `check()` to validate that the
`role` column matches one of the allowed roles.

## Example: role hierarchy

Consider a user with these memberships:

| org_id | role |
|--------|------|
| acme | admin |
| globex | viewer |
| initech | owner |

With a rule requiring `admin` or `owner`:

```sql title="rules.sql"
auth_rules.check('org_roles', 'role', ARRAY['admin', 'owner'])
```

The user can access billing for `acme` and `initech`, but not `globex`.

## Common use cases

These patterns cover typical role-based scenarios.

### Subscription tiers

To restrict features to pro and enterprise customers:

```sql title="claims.sql"
SELECT auth_rules.claim('org_plans', $$
  SELECT om.user_id, o.id AS org_id, o.plan
  FROM org_members om
  JOIN organizations o ON o.id = om.org_id
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('analytics',
  auth_rules.select('id', 'org_id', 'data'),
  auth_rules.in_claim('org_id', 'org_plans',
    auth_rules.check('org_plans', 'plan', ARRAY['pro', 'enterprise']))
);
```

### Approval workflows

To only allow actions on approved projects:

```sql title="claims.sql"
SELECT auth_rules.claim('project_status', $$
  SELECT pm.user_id, p.id AS project_id, p.status
  FROM project_members pm
  JOIN projects p ON p.id = pm.project_id
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('deployments',
  auth_rules.insert(),
  auth_rules.in_claim('project_id', 'project_status',
    auth_rules.check('project_status', 'status', ARRAY['approved']))
);
```

### Active memberships

To only count active (not suspended) members:

```sql title="claims.sql"
SELECT auth_rules.claim('org_membership', $$
  SELECT user_id, org_id, role, status FROM org_members
$$);
```

```sql title="rules.sql"
SELECT auth_rules.rule('documents',
  auth_rules.select('id', 'title'),
  auth_rules.in_claim('org_id', 'org_membership',
    auth_rules.check('org_membership', 'status', ARRAY['active']))
);
```

## Multiple conditions

Each `in_claim()` accepts one `check()` condition. To combine multiple
conditions, use `and_()` with separate `in_claim()` calls:

```sql title="rules.sql"
SELECT auth_rules.rule('billing',
  auth_rules.select('id', 'org_id', 'amount'),
  auth_rules.and_(
    auth_rules.in_claim('org_id', 'org_membership',
      auth_rules.check('org_membership', 'role', ARRAY['admin', 'owner'])),
    auth_rules.in_claim('org_id', 'org_membership',
      auth_rules.check('org_membership', 'status', ARRAY['active']))
  )
);
```

## Default behavior

By default, rows that don't match the `check()` condition are
filtered out silently. If a user queries billing for an org where
they're a viewer, they get an empty result (not an error). This is
the expected behavior for SELECT — you see what you have access to.

To fail with an error instead, use `auth_rules.select_strict()`.
See [Require on SELECT](/docs/auth-rules/strict-mode) for details.

For writes (insert, update, delete), you always get explicit errors
if access is denied.

## Performance

Index the columns you're checking for optimal query performance:

```sql title="indexes.sql"
CREATE INDEX idx_org_members_user_role
ON org_members(user_id, role);
```
